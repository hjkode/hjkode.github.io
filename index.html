<!DOCTYPE html>
<html>
<head>
    <title>hjkode</title>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
</head>
<body>
<nav>
    <ul>
        <li><a href="/">Home</a></li>
    </ul>
</nav>
<div class="container">

    <!-- C++ _countof vs sizeof -->
    <article>
        <div class="date">March 2, 2018</div>
        <div class="blurb">
            <h1>C++ _countof vs sizeof </h1>

            <p>
                <b>_countof</b> is a macro that computes the number of elements in an array. That task sounds quite easy with
                <b>sizeof</b>, so why should I bother using another macro, I thought for a moment (only for a moment).
            </p>

            <p>Firstly, using <b>_countof</b> is semantically clearer than <b>sizeof</b> if the intention of the logic is getting the number
                of elements rather than the size of an array. Secondly, using <b>sizeof</b> for computing the element counts
                could be sometimes confusing thus buggy. See the below example. Can you expect the correct output?
                (Answer in the comment)
            </p>

            <p>
                <pre class="code">
    #include &lt;iostream&gt;

    <font color="blue">class</font> Foo {
    <font color="blue">public</font>:
        Foo() {}
        Foo(int data, char charData) : numData_(data), charData_(charData) {}
    <font color="blue">private</font>:
        <font color="blue">int</font> numData_;
        <font color="blue">char</font> charData_;
    };

    <font color="blue">int</font> main(<font color="blue">int</font> argc, <font color="blue">char </font>*argv[])
    {
        <font color="blue">char</font> charArray[16];
        <font color="blue">wchar_t </font>wcharArray[16];
        Foo fooArray[16];
        Foo* fooPtrArray[16];

        std::cout << <font color="purple">_countof</font>(charArray) << ", " << <font color="blue">sizeof</font>(charArray) << std::endl;     <font color="#008600">// 16, 16</font>
        std::cout << <font color="purple">_countof</font>(wcharArray) << ", " << <font color="blue">sizeof</font>(wcharArray) << std::endl;   <font color="008600">// 16, 32</font>
        std::cout << <font color="purple">_countof</font>(fooArray) << ", " << <font color="blue">sizeof</font>(fooArray) << std::endl;       <font color="008600">// 16, 128</font>
        std::cout << <font color="purple">_countof</font>(fooPtrArray) << ", " << <font color="blue">sizeof</font>(fooPtrArray) << std::endl; <font color="008600">// 16, 64 (x86) and 16, 128 (x64)</font>

        <font color="blue">return</font> 0;
    }
               </pre>
            </p>
            <p>
                It's actually not too difficult to get the correct answer. But it also seems quite easy to make a
                mistake when using with <b>sizeof</b> for computing the number of elements of an array.
            </p>
        </div>
    </article>

    <!-- C++ Regular Expression For File Path -->
    <article>
        <div class="date">February 28, 2018</div>
        <div class="blurb">
            <h1>C++ Regular Expression For File Path</h1>

            <p>
                How do I turn a file path into a C++ regular expression? Once I had to answer this question to check if
                a file path is in or under a certain folder.
            </p>

            <p>
                In C++ you need two backslashes for '\' in string. In regular expression, '\' is used for special
                characters. That means, you need four backslash per each '\' in the regular expression to match a C++
                file path. Because a colon (':') is also a special letter in regular expression you need to add two
                backslashes in front of it.

                <pre class="code">
    std::<font color="0xaadede">string</font> myFilePath = <font color="#df4330">"C:\\Program Files\\TestFolder\\MyTestApp.exe"</font>;
    std::<font color="0xaadede">regex</font> re(<font color="#df4330">"C\\:\\\\Program Files\\\\"</font>, std::regex_constants::icase);
    std::<font color="0xaadede">smatch</font> matchResult;

    if (std::regex_search(myFilePath, matchResult, re))
    {
        // Found a match
    }
               </pre>
            </p>
            <p>
                Note <b>std::regex_constants::icase</b> option is passed for case in-sensitive search when creating the
                regex
                instance. For case sensitive match, simply omit the second parameter.
            </p>
        </div>
    </article>
    <!--Wow64, SysWow64 and Wow6432node -->
    <article>
        <div class="date">February 26, 2018</div>
        <div class="blurb">
            <h1>Wow64, SysWoW64 and Wow6432node</h1>

            <p>
                I found understanding those concepts <i>altogether</i> is more effective for consolidating my
                understanding (&
                memorising) than looking at each of them separately.
            </p>

            <p>
                <b>WoW64</b><br/>
                First of all, WoW64 means Windows 32-bit on Windows 64-bit. In MSDN, WOW64 also means the emulator
                which allows 32-bit applications to run on 64-bit OS.
            </p>

            <p>
                <b>SysWow64</b><br/>
                A 32-bit Windows OS has one Windows system folder named <b>System32</b>. On a 64-bit Windows OS however
                there are
                two Windows system folders . <b>System32</b> for 64-bit files and <b>SysWOW64</b> for 32-bit files.
                Whenever 32-bit
                applications try to access <b>%windir%\System32</b> it is redirected to <b>%windir%\SysWOW64</b>.
            </p>

            <p>
                <b>Wow6432node</b><br/>
                Similarly, to provide a separate view for a 32-bit application running a 64-bit OS, there is the
                registry key named <b>Wow6432node</b> under <b>HKEY_LOCAL_MACHINE\Software</b> on a 64-bit
                Windows OS. This registry key provides a view of <b>HKEY_LOCAL_MACHINE\SOFTWARE</b> for 32-bit
                applications. (Interestingly the registry key often appears on 32-bit Windows OS. While confusing, you
                can simply ignore it.)
            </p>

            <p>
                While the default access rule says, a 32-bit application running WOW64 (the emulator) accesses the
                32-bit registry view and a 64-bit application access the 64-bit registry key, you can use the following
                flags to change the access rule when using them with Windows APIs.

            <table>
                <tr>
                    <th>Flag name</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <th>KEY_WOW64_64KEY</th>
                    <th>Access a 64-bit key from either a 32-bit or 64-bit application</th>
                </tr>
                <tr>
                    <th>KEY_WOW64_32KEY</th>
                    <th>Access a 32-bit key from either a 32-bit or 64-bit application</th>
                </tr>
            </table>
            </p>
        </div>
        <div class="reference">
            References
            <ul class="references">
                <li>
                    <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa384129(v=vs.85).aspx">MSDN:
                        Accessing an
                        Alternate Registry View</a>
                </li>

                <li>
                    <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa384187(v=vs.85).aspx">MSDN: File
                        System Redirector</a>
                </li>
            </ul>
        </div>

    </article>
    <!--Building Boost Library For Windows-->
    <article>
        <div class="date">February 25, 2018</div>
        <div class="blurb">
            <h1>Building boost library for Windows</h1>

            <p>
                It is supposed to be pretty straightforward. But whenever I needed a specific set of boost libraries it
                took longer than expected. Basically there are just three
                steps for building boost library for Windows.<br/>

            <ul class="steps">
                <li>Step 1: Download a boost library zip file and unzip</li>
                <li>Step 2: Generate the boost build tool (b2.exe)</li>
                <li>Step 3: Using the build tool, build a version of boost library</li>
            </ul>

            <p>
                <b>Step 1</b>
                Download boost library from <a href="http://www.boost.org/users/download/">Boost page</a>.<br/>
                While optional, it is a good practice to check the hash value of the file. For instance, use
                <b>CertUtil.exe</b> to calculate the hash value of the downloaded zip file and compare it with
                the one from the boost download page.

            <div class="code">C:\Users\hjkode\CertUtil -hashfile .\Downloads\boost_1_66_0.zip SHA256</div>

            </p>
            <p>
                <b>Step 2</b>
                Unzip it and run <b>bootstrap.bat</b> to create the build tool. This will generate <b>b2.exe</b>.
            </p>

            <p>
                <b>Step 3</b>
                Run <b>b2.exe</b> with options to create correct version(s) of boost libraries. Without any
                option, running <b>b2.exe</b> will generate all variants of boost libraries with default options and
                this could take a quite long time. Below shows an example of building a 32-bit release version of boost
                libraries.

            <div class="code">
                C:\b2 toolset=msvc-14.1 -j4 --build-dir="C:\Users\hjkyod\Documents\dev\boost-build" address-model=32
                architecture=x86 --build-type=minimal stage --stagedir=stage/win32
            </div>
            <div class="explanation">
                <b>toolset:</b> Compiler version e.g.) msvc-14.1 for Visual Studio 17<br/>
                <b>-j4:</b> Number cores to run in parallel e.g.) 4<br/>
                <b>--build-dir:</b> Build directory<br/>
                <b>address-model:</b> Either 32-bit or 64-bit code generation<br/>
                <b>architecture:</b> Process architecture<br/>
                <b>--build-type</b>: Determines which build types of the libraries are created. <b>minimal</b> option
                means release builds.<br/>
                <b>stage:</b> Request output files to be copied to <b>stage</b> folder<br/>
                <b>stagedir:</b> Stage folder<br/>
            </div>
            <p>
                For the full list of options, see <a
                    href="http://www.boost.org/build/doc/html/bbv2/overview/invocation.html">here</a>.
            </p>

        </div>
    </article>
    <!--New Chapter-->
    <article>
        <div class="date">February 22, 2018</div>
        <div class="blurb">
            <h1>New chapter</h1>

            <p>
                This is a blog to share tips and knowledge gained from my side projects. I tried something similar,
                at least twice in the past but it didn't last long. It was perhaps because I was putting too much
                pressure
                on me, wanting to deliver something <i>creative and big</i>. This time, I will start small
                while trying to make this blog useful for me as well as others.
            </p>
        </div>
    </article>
</div>

</body>
</html>
